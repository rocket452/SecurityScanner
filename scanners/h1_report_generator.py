"""HackerOne Report Generator using AI.

Generates professional, submission-ready vulnerability reports for HackerOne
using AI (OpenAI GPT or Anthropic Claude) to analyze scan findings.
"""
import json
import os
from typing import Dict, List, Optional, Tuple
from pathlib import Path
import logging

# Configure logging
logger = logging.getLogger(__name__)

try:
    import openai
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False
    logger.warning('OpenAI library not available. Install with: pip install openai')

try:
    import anthropic
    ANTHROPIC_AVAILABLE = True
except ImportError:
    ANTHROPIC_AVAILABLE = False
    logger.warning('Anthropic library not available. Install with: pip install anthropic')


class H1ReportGenerator:
    """Generate professional HackerOne vulnerability reports using AI."""
    
    # HackerOne severity levels
    SEVERITY_LEVELS = ['none', 'low', 'medium', 'high', 'critical']
    
    # Report template structure
    REPORT_TEMPLATE = """# Vulnerability Report for HackerOne

## Title
{title}

## Summary
{summary}

## Severity Assessment
**Severity:** {severity}
**CVSS Score:** {cvss_score}

## Vulnerability Details
{details}

## Steps to Reproduce
{steps}

## Impact
{impact}

## Proof of Concept
{poc}

## Remediation Recommendations
{remediation}

## Supporting Evidence
{evidence}

---
*Report generated by SecurityScanner AI Report Generator*
"""
    
    def __init__(self, ai_provider: str = 'openai', api_key: Optional[str] = None, model: Optional[str] = None):
        """Initialize the report generator.
        
        Args:
            ai_provider: AI provider to use ('openai' or 'anthropic')
            api_key: API key for the AI provider (if not set in environment)
            model: Model name to use (defaults to provider's recommended model)
        """
        self.ai_provider = ai_provider.lower()
        self.model = model
        
        # Set up AI client
        if self.ai_provider == 'openai':
            if not OPENAI_AVAILABLE:
                raise ImportError('OpenAI library not installed. Install with: pip install openai')
            
            api_key = api_key or os.getenv('OPENAI_API_KEY')
            if not api_key:
                raise ValueError('OpenAI API key not provided. Set OPENAI_API_KEY environment variable.')
            
            self.client = openai.OpenAI(api_key=api_key)
            self.model = model or 'gpt-4o'  # Default to GPT-4o
            
        elif self.ai_provider == 'anthropic':
            if not ANTHROPIC_AVAILABLE:
                raise ImportError('Anthropic library not installed. Install with: pip install anthropic')
            
            api_key = api_key or os.getenv('ANTHROPIC_API_KEY')
            if not api_key:
                raise ValueError('Anthropic API key not provided. Set ANTHROPIC_API_KEY environment variable.')
            
            self.client = anthropic.Anthropic(api_key=api_key)
            self.model = model or 'claude-3-5-sonnet-20241022'  # Default to Claude 3.5 Sonnet
            
        else:
            raise ValueError(f'Unsupported AI provider: {ai_provider}. Use "openai" or "anthropic".')
        
        logger.info(f'Initialized H1 Report Generator with {self.ai_provider} ({self.model})')
    
    def generate_report(self, vulnerability: Dict, target_url: str, program_name: Optional[str] = None) -> str:
        """Generate a professional HackerOne report for a single vulnerability.
        
        Args:
            vulnerability: Vulnerability data from scan results
            target_url: Target URL where vulnerability was found
            program_name: HackerOne program name (optional)
        
        Returns:
            Formatted HackerOne report as markdown string
        """
        logger.info(f'Generating H1 report for {vulnerability.get("type", "unknown")} vulnerability')
        
        # Build context for AI
        vuln_context = self._build_vulnerability_context(vulnerability, target_url, program_name)
        
        # Generate report components using AI
        report_data = self._generate_report_with_ai(vuln_context)
        
        # Format final report
        report = self.REPORT_TEMPLATE.format(**report_data)
        
        return report
    
    def generate_batch_reports(self, scan_results_file: str, output_dir: str = './h1_reports') -> List[str]:
        """Generate HackerOne reports for all vulnerabilities in a scan results file.
        
        Args:
            scan_results_file: Path to JSON scan results file
            output_dir: Directory to save individual reports
        
        Returns:
            List of paths to generated report files
        """
        # Load scan results
        with open(scan_results_file, 'r') as f:
            scan_data = json.load(f)
        
        # Create output directory
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        
        generated_reports = []
        target = scan_data.get('target', 'unknown')
        
        # Process each result
        for idx, result in enumerate(scan_data.get('results', []), 1):
            url = result.get('url')
            vulnerabilities = result.get('vulnerabilities', [])
            
            # Generate report for each vulnerability
            for vuln_idx, vuln in enumerate(vulnerabilities, 1):
                try:
                    report = self.generate_report(vuln, url, target)
                    
                    # Save report to file
                    vuln_type = vuln.get('type', 'unknown').replace(' ', '_')
                    safe_url = url.replace('://', '_').replace('/', '_').replace('.', '_')
                    filename = f'h1_report_{safe_url}_{vuln_type}_{idx}_{vuln_idx}.md'
                    filepath = output_path / filename
                    
                    with open(filepath, 'w') as f:
                        f.write(report)
                    
                    generated_reports.append(str(filepath))
                    logger.info(f'Generated report: {filepath}')
                    
                except Exception as e:
                    logger.error(f'Failed to generate report for vulnerability {vuln_idx}: {e}')
        
        return generated_reports
    
    def _build_vulnerability_context(self, vulnerability: Dict, target_url: str, program_name: Optional[str]) -> str:
        """Build context string for AI prompt."""
        context = f"""Target URL: {target_url}
        
Vulnerability Type: {vulnerability.get('type', 'Unknown')}
Severity: {vulnerability.get('severity', 'Unknown')}
Description: {vulnerability.get('description', 'No description provided')}
Status Code: {vulnerability.get('status_code', 'N/A')}
"""
        
        if program_name:
            context = f"HackerOne Program: {program_name}\n\n" + context
        
        # Add any additional context from vulnerability data
        if 'sources' in vulnerability:
            context += f"\nDetected by: {', '.join(vulnerability['sources'])}"
        
        return context
    
    def _generate_report_with_ai(self, vuln_context: str) -> Dict[str, str]:
        """Use AI to generate report components."""
        system_prompt = """You are a professional security researcher writing vulnerability reports for HackerOne bug bounty programs. 

Your reports should be:
- Clear, concise, and professional
- Follow HackerOne's best practices
- Include accurate technical details
- Provide actionable remediation steps
- Use proper markdown formatting
- Be respectful and constructive

Generate a comprehensive vulnerability report with the following sections:
1. Title (concise, descriptive, mentions vulnerability type and location)
2. Summary (2-3 sentences explaining what was found)
3. Severity (none/low/medium/high/critical based on impact)
4. CVSS Score (estimated score with reasoning)
5. Vulnerability Details (technical explanation)
6. Steps to Reproduce (numbered, clear steps)
7. Impact (potential consequences if exploited)
8. Proof of Concept (example exploit or demonstration)
9. Remediation (specific recommendations to fix)
10. Supporting Evidence (additional technical details)

Provide the response as a JSON object with these exact keys: title, summary, severity, cvss_score, details, steps, impact, poc, remediation, evidence"""

        user_prompt = f"""Generate a professional HackerOne vulnerability report based on the following scan findings:

{vuln_context}

Provide a complete, submission-ready report following HackerOne's guidelines."""

        try:
            if self.ai_provider == 'openai':
                response = self.client.chat.completions.create(
                    model=self.model,
                    messages=[
                        {"role": "system", "content": system_prompt},
                        {"role": "user", "content": user_prompt}
                    ],
                    response_format={"type": "json_object"},
                    temperature=0.7
                )
                report_json = json.loads(response.choices[0].message.content)
                
            elif self.ai_provider == 'anthropic':
                response = self.client.messages.create(
                    model=self.model,
                    max_tokens=4096,
                    system=system_prompt,
                    messages=[
                        {"role": "user", "content": user_prompt}
                    ],
                    temperature=0.7
                )
                # Extract JSON from Claude's response
                content = response.content[0].text
                # Try to parse as JSON directly, or extract JSON from markdown code blocks
                if content.strip().startswith('{'):
                    report_json = json.loads(content)
                else:
                    # Extract from code block
                    import re
                    json_match = re.search(r'```(?:json)?\s*({.*?})\s*```', content, re.DOTALL)
                    if json_match:
                        report_json = json.loads(json_match.group(1))
                    else:
                        raise ValueError('Could not extract JSON from Claude response')
            
            # Validate required keys
            required_keys = ['title', 'summary', 'severity', 'cvss_score', 'details', 'steps', 'impact', 'poc', 'remediation', 'evidence']
            for key in required_keys:
                if key not in report_json:
                    report_json[key] = 'Not available'
            
            return report_json
            
        except Exception as e:
            logger.error(f'AI report generation failed: {e}')
            # Return fallback report
            return self._generate_fallback_report(vuln_context)
    
    def _generate_fallback_report(self, vuln_context: str) -> Dict[str, str]:
        """Generate a basic report when AI fails."""
        return {
            'title': 'Security Vulnerability Detected',
            'summary': 'A security vulnerability was detected during automated scanning.',
            'severity': 'medium',
            'cvss_score': 'To be determined',
            'details': vuln_context,
            'steps': '1. Navigate to the affected URL\n2. Observe the vulnerability behavior',
            'impact': 'This vulnerability may allow unauthorized access or information disclosure.',
            'poc': 'See vulnerability details above.',
            'remediation': 'Please review the vulnerability details and apply appropriate security patches.',
            'evidence': vuln_context
        }


def main():
    """CLI interface for generating HackerOne reports."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description='Generate professional HackerOne reports from scan results using AI',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  # Generate reports from scan results using OpenAI
  python -m scanners.h1_report_generator -i ./reports/scan_results.json -o ./h1_reports
  
  # Use Anthropic Claude instead
  python -m scanners.h1_report_generator -i ./reports/scan_results.json --provider anthropic
  
  # Specify custom model
  python -m scanners.h1_report_generator -i ./reports/scan_results.json --model gpt-4-turbo
        '''
    )
    
    parser.add_argument(
        '-i', '--input',
        required=True,
        help='Input JSON scan results file'
    )
    parser.add_argument(
        '-o', '--output',
        default='./h1_reports',
        help='Output directory for generated reports (default: ./h1_reports)'
    )
    parser.add_argument(
        '--provider',
        choices=['openai', 'anthropic'],
        default='openai',
        help='AI provider to use (default: openai)'
    )
    parser.add_argument(
        '--model',
        help='Model name to use (default: provider-specific default)'
    )
    parser.add_argument(
        '--api-key',
        help='API key for AI provider (default: from environment variable)'
    )
    
    args = parser.parse_args()
    
    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='[%(levelname)s] %(message)s'
    )
    
    try:
        # Initialize generator
        generator = H1ReportGenerator(
            ai_provider=args.provider,
            api_key=args.api_key,
            model=args.model
        )
        
        # Generate reports
        logger.info(f'Processing scan results from: {args.input}')
        reports = generator.generate_batch_reports(args.input, args.output)
        
        logger.info(f'\n‚úÖ Successfully generated {len(reports)} HackerOne report(s)')
        logger.info(f'Reports saved to: {args.output}\n')
        
        # Print report locations
        for report_path in reports:
            print(f'  üìÑ {report_path}')
        
    except Exception as e:
        logger.error(f'\n‚ùå Error: {e}')
        return 1
    
    return 0


if __name__ == '__main__':
    import sys
    sys.exit(main())
